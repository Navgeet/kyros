#!/usr/bin/env python3
"""
Action execution system for Kyros.
Executes Python code generated by the agent using pyautogui and other automation tools.
"""

import subprocess
import time
import re
import logging
from typing import Dict, List, Optional, Union, Any
from io import StringIO
import sys
import traceback

try:
    import pyautogui
    import psutil
except ImportError as e:
    print(f"Missing required packages: {e}")
    print("Please install: pip install pyautogui psutil")

logger = logging.getLogger("kyros.execution")

# Configure pyautogui safety
pyautogui.FAILSAFE = True
pyautogui.PAUSE = 0.1  # Small pause between actions


class ActionExecutor:
    """Executes actions generated by the Kyros agent."""

    def __init__(self, screen_size=(1920, 1080)):
        self.screen_size = screen_size
        self.last_result = ""

        # Set up safe execution environment
        self.safe_globals = {
            '__builtins__': {
                'len': len,
                'str': str,
                'int': int,
                'float': float,
                'bool': bool,
                'list': list,
                'dict': dict,
                'tuple': tuple,
                'range': range,
                'print': print,
                'abs': abs,
                'min': min,
                'max': max,
                'round': round,
                'sum': sum,
                'reversed': reversed,
                '__import__': __import__,
                'FileNotFoundError': FileNotFoundError,
                'Exception': Exception,
            },
            'pyautogui': pyautogui,
            'time': time,
            'subprocess': subprocess,
        }

    def _fix_pyautogui_less_than_bug(self, command: str) -> str:
        """
        Fix PyAutoGUI '<' character bug by converting it to hotkey("shift", ',') calls.
        Based on OSWorld implementation.
        """
        # Pattern to match press('<') or press('\u003c') calls
        press_pattern = r'pyautogui\.press\(["\'](?:<|\\u003c)["\']\)'

        # Handle press('<') calls
        def replace_press_less_than(match):
            return 'pyautogui.hotkey("shift", ",")'

        # First handle press('<') calls
        command = re.sub(press_pattern, replace_press_less_than, command)

        # Pattern to match typewrite calls with quoted strings
        typewrite_pattern = r'pyautogui\.typewrite\((["\'])(.*?)\1\)'

        # Then handle typewrite calls
        def process_typewrite_match(match):
            quote_char = match.group(1)
            content = match.group(2)

            # Preprocess: Try to decode Unicode escapes like \u003c to actual '<'
            try:
                decoded_content = content.encode('utf-8').decode('unicode_escape')
                content = decoded_content
            except UnicodeDecodeError:
                pass

            # Check if content contains '<'
            if '<' not in content:
                return match.group(0)

            # Split by '<' and rebuild
            parts = content.split('<')
            result_parts = []

            for i, part in enumerate(parts):
                if i == 0:
                    # First part
                    if part:
                        result_parts.append(f"pyautogui.typewrite({quote_char}{part}{quote_char})")
                else:
                    # Add hotkey for '<' and then typewrite for the rest
                    result_parts.append('pyautogui.hotkey("shift", ",")')
                    if part:
                        result_parts.append(f"pyautogui.typewrite({quote_char}{part}{quote_char})")

            return '; '.join(result_parts)

        command = re.sub(typewrite_pattern, process_typewrite_match, command)

        return command

    def _safe_exec(self, code: str) -> tuple[bool, str]:
        """
        Safely execute Python code with restricted globals.

        Args:
            code: Python code to execute

        Returns:
            tuple: (success, result_message)
        """
        try:
            # Create a copy of safe globals for this execution
            exec_globals = self.safe_globals.copy()
            exec_locals = {}

            # Capture stdout
            old_stdout = sys.stdout
            captured_output = StringIO()
            sys.stdout = captured_output

            try:
                # Execute the code
                exec(code, exec_globals, exec_locals)

                # Get any printed output
                output = captured_output.getvalue()

                return True, output.strip() if output.strip() else "Action executed successfully"

            finally:
                sys.stdout = old_stdout

        except Exception as e:
            error_msg = f"Execution error: {str(e)}"
            logger.error(f"Failed to execute code: {code}\nError: {error_msg}")
            return False, error_msg

    def execute_action(self, action: Union[str, List[str]]) -> str:
        """
        Execute a single action or list of actions.

        Args:
            action: Action command(s) to execute

        Returns:
            str: Result of the action execution
        """
        if isinstance(action, list):
            # Execute multiple actions
            results = []
            for act in action:
                result = self.execute_action(act)
                results.append(result)
            return "; ".join(results)

        action_str = str(action).strip()
        logger.info(f"Executing action: {action_str}")

        # Handle special commands (both standalone and compound)
        special_commands = ["WAIT", "DONE", "FAIL"]

        # Check if action is purely a special command
        if action_str in special_commands:
            if action_str == "WAIT":
                time.sleep(2)
                result = "Waited 2 seconds"
            elif action_str == "DONE":
                result = "Task completed successfully"
            elif action_str == "FAIL":
                result = "Task failed"

            logger.info(f"Special command result: {result}")
            self.last_result = result
            return result

        # Handle compound actions that end with special commands
        for cmd in special_commands:
            if action_str.endswith(f"; {cmd}") or action_str.endswith(f";{cmd}"):
                # Split the action into code part and special command
                if action_str.endswith(f"; {cmd}"):
                    code_part = action_str[:-len(f"; {cmd}")].strip()
                else:
                    code_part = action_str[:-len(f";{cmd}")].strip()

                # Execute the code part first
                if code_part:
                    try:
                        fixed_code = self._fix_pyautogui_less_than_bug(code_part)
                        success, code_result = self._safe_exec(fixed_code)
                        if not success:
                            logger.error(f"Code execution failed: {code_result}")
                            self.last_result = code_result
                            return code_result
                    except Exception as e:
                        error_msg = f"Error executing code part: {str(e)}"
                        logger.error(error_msg)
                        self.last_result = error_msg
                        return error_msg

                # Then handle the special command
                if cmd == "WAIT":
                    time.sleep(2)
                    result = f"{code_result if code_part else ''}; Waited 2 seconds"
                elif cmd == "DONE":
                    result = f"{code_result if code_part else ''}; Task completed successfully"
                elif cmd == "FAIL":
                    result = f"{code_result if code_part else ''}; Task failed"

                logger.info(f"Compound action result: {result}")
                self.last_result = result
                return result

        # Handle empty or invalid actions
        if not action_str or action_str.lower() == "none":
            result = "No action to execute"
            logger.warning(result)
            self.last_result = result
            return result

        try:
            # Apply PyAutoGUI fixes
            fixed_action = self._fix_pyautogui_less_than_bug(action_str)

            # For now, skip safety checks to avoid regex parsing issues
            # TODO: Improve safety checks parsing
            safe_action = fixed_action

            # Execute the action
            success, result = self._safe_exec(safe_action)

            if success:
                logger.info(f"Action executed successfully: {result}")
            else:
                logger.error(f"Action execution failed: {result}")

            self.last_result = result
            return result

        except Exception as e:
            error_msg = f"Unexpected error executing action: {str(e)}"
            logger.error(error_msg)
            logger.error(traceback.format_exc())
            self.last_result = error_msg
            return error_msg

    def _add_safety_checks(self, code: str) -> str:
        """
        Add safety checks to coordinate-based actions.

        Args:
            code: Original code

        Returns:
            str: Code with safety checks added
        """
        # Add bounds checking for click coordinates
        click_pattern = r'pyautogui\.click\(\s*([^,\)]+)(?:,\s*([^,\)]+))?\s*(?:,\s*([^,\)]+))?\s*(?:,\s*([^,\)]+))?\s*\)'

        def replace_click(match):
            x_expr = match.group(1).strip()
            y_expr = match.group(2).strip() if match.group(2) else "None"
            clicks = match.group(3).strip() if match.group(3) else "1"
            button = match.group(4).strip() if match.group(4) else "'left'"

            # If coordinates are in list/tuple format [x, y], extract them
            if x_expr.startswith('[') and ']' in x_expr:
                coords = x_expr.strip('[]').split(',')
                if len(coords) >= 2:
                    x_expr = coords[0].strip()
                    y_expr = coords[1].strip()
            elif x_expr.startswith('(') and ')' in x_expr:
                coords = x_expr.strip('()').split(',')
                if len(coords) >= 2:
                    x_expr = coords[0].strip()
                    y_expr = coords[1].strip()

            if y_expr == "None":
                return match.group(0)  # Return original if y coordinate not found

            # Generate safe click code
            safe_code = f"""
# Safe click with bounds checking
_x, _y = {x_expr}, {y_expr}
_x = max(0, min(_x, {self.screen_size[0] - 1}))
_y = max(0, min(_y, {self.screen_size[1] - 1}))
pyautogui.click(_x, _y, clicks={clicks}, button={button})
print("Clicked at (" + str(_x) + ", " + str(_y) + ")")
""".strip()
            return safe_code

        code = re.sub(click_pattern, replace_click, code)

        # Add safety for drag operations
        drag_pattern = r'pyautogui\.drag\(\s*([^,\)]+)\s*,\s*([^,\)]+)\s*(?:,\s*([^,\)]+))?\s*\)'

        def replace_drag(match):
            dx_expr = match.group(1).strip()
            dy_expr = match.group(2).strip()
            duration = match.group(3).strip() if match.group(3) else "0.5"

            safe_code = f"""
# Safe drag with bounds checking
_dx, _dy = {dx_expr}, {dy_expr}
_current_pos = pyautogui.position()
_new_x = max(0, min(_current_pos.x + _dx, {self.screen_size[0] - 1}))
_new_y = max(0, min(_current_pos.y + _dy, {self.screen_size[1] - 1}))
pyautogui.drag(_new_x - _current_pos.x, _new_y - _current_pos.y, duration={duration})
print("Dragged to (" + str(_new_x) + ", " + str(_new_y) + ")")
""".strip()
            return safe_code

        code = re.sub(drag_pattern, replace_drag, code)

        return code

    def get_last_result(self) -> str:
        """Get the result of the last executed action."""
        return self.last_result


def execute_action(action: Union[str, List[str]], screen_size=(1920, 1080)) -> str:
    """
    Convenience function to execute an action.

    Args:
        action: Action command(s) to execute
        screen_size: Screen dimensions for safety checks

    Returns:
        str: Result of the action execution
    """
    executor = ActionExecutor(screen_size)
    return executor.execute_action(action)


def check_automation_dependencies() -> List[str]:
    """
    Check if required automation dependencies are available.

    Returns:
        List[str]: List of missing dependencies
    """
    missing = []

    try:
        import pyautogui
        # Test if pyautogui can get screen size (indicates X11 is available)
        pyautogui.size()
    except ImportError:
        missing.append("pyautogui (pip install pyautogui)")
    except Exception:
        missing.append("X11 display server (automation requires graphical environment)")

    try:
        import psutil
    except ImportError:
        missing.append("psutil (pip install psutil)")

    return missing


if __name__ == "__main__":
    # Test the action execution system
    logging.basicConfig(level=logging.INFO)

    print("üîç Checking automation dependencies...")
    missing = check_automation_dependencies()
    if missing:
        print("‚ùå Missing dependencies:")
        for dep in missing:
            print(f"  - {dep}")
        print("\nPlease install missing dependencies before running.")
        sys.exit(1)
    else:
        print("‚úÖ All automation dependencies available")

    print("\nüéÆ Testing action execution...")
    executor = ActionExecutor()

    # Test basic actions
    test_actions = [
        "WAIT",
        "print('Hello from action executor')",
        "pyautogui.position()",
        "DONE"
    ]

    for action in test_actions:
        print(f"\nTesting: {action}")
        result = executor.execute_action(action)
        print(f"Result: {result}")

    print("\n‚úÖ Action execution system test completed")